# Hello, World

This example serves as an introduction to writing TEE-applications with the
[Bearclave SDK](https://github.com/tahardi/bearclave). This includes how to
write, build, and deploy applications to real cloud-based TEE platforms. For
an overview on what TEEs are and the different platforms (e.g., AWS Nitro
Enclaves, AMD SEV-SNP, Intel TDX) refer to the
[TEE concepts](https://github.com/tahardi/bearclave/blob/main/docs/concepts.md)
document.

## Application Structure

Bearclave applications are split into two programs: a Proxy and an Enclave.
This architecture is necessary to run on the AWS Nitro Enclave platform. For
the sake of consistency and developer experience, we assume this architecture
for AMD SEV-SNP and Intel TDX as well. Doing so allows us to write applications
without worrying about the underlying TEE platform.

### Enclave

We use the term _Enclave_ to refer to the program that executes within a TEE
and contains your business logic and data. As the program running within a TEE,
the Enclave has certain properties and functionalities not afforded to "normal"
programs. The confidentiality and integrity of the Enclave's code and data is
assured, even in the face of a malicious Host OS or Hypervisor. The Enclave can
**prove** this to outside parties by generating attestation reports. As we will
demonstrate in this example, attestation reports can also be used to "witness"
arbitrary data. This is especially useful if you want to prove to some
other party that your Enclave program has seen or generated a given set of data.

### Proxy

We use the term _Proxy_ to refer to the program that handles translating and
forwarding communications between the Enclave and clients. It is important to
note that **the Proxy is outside our trust boundary**. Because of the Nitro
Enclave architecture, we have to always assume that the Proxy is run outside
the TEE (even though that is not true for SEV-SNP and TDX). The only assumption
we make is that the Proxy will (eventually) forward our requests and responses.
If we are receiving or sending sensitive data, however, we need to take proper
precautions (e.g., use authenticated encryption) to ensure the Proxy cannot
modify or read our data.

### Nonclave

We use the term _Nonclave_ to refer to the "non-Enclave" program, which
represents the client(s) of our application. They may want to verify that
the Enclave is running within a genuine TEE before sending over sensitive
data or asking the Enclave to perform some action. This is done by requesting
and verifying an attestation report, which we will demonstrate in this example.

## Walkthrough

This example demonstrates a simple scenario where the Nonclave wants the
Enclave to "witness" some data.

1. Our Nonclave begins by reading in a configuration file and creating a
Bearclave `tee.Verifier`. The verifier is used to verify attestation reports
generated by the Enclave.

<!-- pluck("go", "function", "main", "hello-world/nonclave/main.go", 27, 40) -->
```go
func main() {
	// ...
	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	config, err := setup.LoadConfig(configFile)
	if err != nil {
		logger.Error("loading config", slog.String("error", err.Error()))
		return
	}
	logger.Info("loaded config", slog.Any(configFile, config))

	verifier, err := tee.NewVerifier(config.Platform)
	if err != nil {
		logger.Error("making verifier", slog.String("error", err.Error()))
		return
	}
	// ...
}
```

2. The Nonclave then creates an HTTP client and sends an attestation request to
the Enclave containing the data to "witness" and a nonce for freshness. The
`networking.Client` is a wrapper around `http.Client` and contains
example-specific methods for sending requests to the Enclave. It is purely
for convenience and readability.

<!-- pluck("go", "function", "main", "hello-world/nonclave/main.go", 41, 53) -->
```go
func main() {
	// ...
	nonce := []byte("random nonce here")
	want := []byte("Hello, world!")
	url := "http://" + net.JoinHostPort(host, strconv.Itoa(port))
	client := networking.NewClient(url)

	ctx, cancel := context.WithTimeout(context.Background(), DefaultTimeout)
	defer cancel()
	got, err := client.AttestUserData(ctx, nonce, want)
	if err != nil {
		logger.Error("attesting userdata", slog.String("error", err.Error()))
		return
	}
	// ...
}
```

3. Remember that the Proxy is responsible for forwarding requests and responses
between the Enclave and the Nonclave. In this example, the Proxy configures
a TCP `tee.Socket` connection to the Enclave. On AWS Nitro, the underlying socket
is actually a _virtual_ socket, whereas on AMD SEV-SNP and Intel TDX it is a
traditional socket.

<!-- pluck("go", "function", "main", "hello-world/proxy/main.go", 10, 30) -->
```go
func main() {
	// ...
	config, err := setup.LoadConfig(configFile)
	if err != nil {
		logger.Error("loading config", slog.String("error", err.Error()))
		return
	}
	logger.Info("loaded config", slog.Any(configFile, config))

	sockCtx, sockCancel := context.WithTimeout(context.Background(), DefaultTimeout)
	defer sockCancel()
	socket, err := tee.NewSocket(
		sockCtx,
		config.Platform,
		tee.NetworkTCP4,
		config.Proxy.Addr,
	)
	if err != nil {
		logger.Error("making socket", slog.String("error", err.Error()))
		return
	}
	defer socket.Close()
	// ...
}
```

4. The Proxy defines an HTTP handler that extracts the request data from the
HTTP request body and forwards it to the Enclave via the socket. Normally, we
would want as little logic as possible in the Proxy, as it is outside our
trust boundary. In this example, however, we keep all HTTP server logic in the
Proxy to keep the Enclave simple and easy to understand. Our
[hello-http](../hello-http/README.md) demonstrates how to configure the Proxy
as a true HTTP reverse proxy, and the Enclave as an HTTP server.

<!-- pluck("go", "function", "MakeAttestHandler", "hello-world/proxy/main.go", 0, 0) -->
```go
func MakeAttestHandler(
	socket *tee.Socket,
	enclaveAddr string,
	logger *slog.Logger,
) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			logger.Error("reading request body", slog.String("error", err.Error()))
			tee.WriteError(w, fmt.Errorf("reading request body: %w", err))
			return
		}
		defer r.Body.Close()

		sendCtx, sendCancel := context.WithTimeout(r.Context(), DefaultTimeout)
		defer sendCancel()

		logger.Info("sending attestation request to enclave...")
		err = socket.Send(sendCtx, enclaveAddr, bodyBytes)
		if err != nil {
			logger.Error("sending attestation to enclave", slog.String("error", err.Error()))
			tee.WriteError(w, fmt.Errorf("sending attestation to enclave: %w", err))
			return
		}

		receiveCtx, receiveCancel := context.WithTimeout(r.Context(), DefaultTimeout)
		defer receiveCancel()

		logger.Info("waiting for attestation from enclave...")
		attestBytes, err := socket.Receive(receiveCtx)
		if err != nil {
			logger.Error("receiving attestation from enclave", slog.String("error", err.Error()))
			tee.WriteError(w, fmt.Errorf("receiving attestation from enclave: %w", err))
			return
		}

		attestResult := tee.AttestResult{}
		err = json.Unmarshal(attestBytes, &attestResult)
		if err != nil {
			logger.Error("unmarshaling attestation", slog.String("error", err.Error()))
			tee.WriteError(w, fmt.Errorf("unmarshaling attestation: %w", err))
			return
		}

		resp := networking.AttestUserDataResponse{Attestation: &attestResult}
		tee.WriteResponse(w, resp)
		logger.Info("sent attestation to client")
	}
}
```

5. The Enclave configures a `tee.Socket` for communicating with the Proxy, and
a `tee.Attester` for generating attestation reports. The Bearclave SDK
hides the underlying platform differences behind a simple interface.

<!-- pluck("go", "function", "main", "hello-world/enclave/main.go", 10, 35) -->
```go
func main() {
	// ...
	config, err := setup.LoadConfig(configFile)
	if err != nil {
		logger.Error("loading config", slog.Any("error", err))
		return
	}
	logger.Info("loaded config", slog.Any(configFile, config))

	attester, err := tee.NewAttester(config.Platform)
	if err != nil {
		logger.Error("making attester", slog.String("error", err.Error()))
		return
	}

	ctx, cancel := context.WithTimeout(context.Background(), DefaultTimeout)
	defer cancel()
	socket, err := tee.NewSocket(
		ctx,
		config.Platform,
		tee.NetworkTCP4,
		config.Enclave.Addr,
	)
	if err != nil {
		logger.Error("making socket", slog.String("error", err.Error()))
		return
	}
	// ...
}
```

6. Upon receiving a request from the Proxy, the Enclave generates an attestation
report containing the nonce and the data to "witness". Afterward, it sends the
attestation report back to the Proxy, which returns it to the Nonclave.

<!-- pluck("go", "function", "main", "hello-world/enclave/main.go", 36, 80) -->
```go
func main() {
	// ...
	for {
		logger.Info("waiting to receive userdata from enclave-proxy...")
		ctx := context.Background()
		reqBytes, err := socket.Receive(ctx)
		if err != nil {
			logger.Error("receiving userdata", slog.String("error", err.Error()))
			return
		}

		req := networking.AttestUserDataRequest{}
		err = json.Unmarshal(reqBytes, &req)
		if err != nil {
			logger.Error("unmarshaling request", slog.String("error", err.Error()))
			return
		}

		userdata := req.UserData
		logger.Info(
			"attesting",
			slog.String("nonce", string(req.Nonce)),
			slog.String("userdata", string(userdata)),
		)
		attestResult, err := attester.Attest(
			tee.WithAttestNonce(req.Nonce),
			tee.WithAttestUserData(userdata),
		)
		if err != nil {
			logger.Error("attesting", slog.String("error", err.Error()))
			return
		}

		attestBytes, err := json.Marshal(attestResult)
		if err != nil {
			logger.Error("marshaling attestation", slog.String("error", err.Error()))
			return
		}

		logger.Info("sending attestation to enclave-proxy...")
		err = socket.Send(ctx, config.Proxy.Addr, attestBytes)
		if err != nil {
			logger.Error("sending attestation", slog.String("error", err.Error()))
			return
		}
	}
}
```

7. Upon receiving the attestation report, the Nonclave verifies it using the
nonce and the expected "measurement". A _measurement_ represents the expected
state of the TEE hardware and software. This may be a cryptographic
hash (or hashes) of the Enclave's code, the firmware version, the boot arguments,
etc. Verifying the attestation report ensures that the Enclave is running the
expected code within a genuine TEE and has not been tampered with. Not only
are we assured of the Enclave's authenticity and integrity, but we can provide
the attestation report to other parties to prove that the Enclave witnessed
our data.

<!-- pluck("go", "function", "main", "hello-world/nonclave/main.go", 48, 70) -->
```go
func main() {
	// ...
	got, err := client.AttestUserData(ctx, nonce, want)
	if err != nil {
		logger.Error("attesting userdata", slog.String("error", err.Error()))
		return
	}

	measurement := config.Nonclave.Measurement
	verified, err := verifier.Verify(
		got.Attestation,
		tee.WithVerifyMeasurement(measurement),
		tee.WithVerifyNonce(nonce),
		tee.WithVerifyDebug(verifyDebug),
	)
	if err != nil {
		logger.Error("verifying attestation", slog.String("error", err.Error()))
		return
	}

	logger.Info(
		"attested and verified userdata",
		slog.String("userdata", string(verified.UserData)),
	)
}
```

## Running Locally

Follow the setup
[instructions](https://github.com/tahardi/bearclave/blob/main/docs/setup.md#install--setup-no-tee)
in the Bearclave SDK repository to configure your local environment. Afterward,
you can run the example locally by running `make`in the `hello-world` directory:
```bash
make

# You should see output similar to the following:
[enclave        ] time=2026-01-18T09:39:12.061-05:00 level=INFO msg="loaded config" configs/enclave/notee.yaml="&{Platform:notee Enclave:{Addr:http://127.0.0.1:8083 AddrTLS: Args:map[]} Nonclave:{Measurement: Args:map[]} Proxy:{Addr:http://127.0.0.1:8082 AddrTLS: RevAddr:http://0.0.0.0:8080 RevAddrTLS:}}"
[enclave        ] time=2026-01-18T09:39:12.062-05:00 level=INFO msg="waiting to receive userdata from enclave-proxy..."
[proxy  ] time=2026-01-18T09:39:12.065-05:00 level=INFO msg="loaded config" configs/enclave/notee.yaml="&{Platform:notee Enclave:{Addr:http://127.0.0.1:8083 AddrTLS: Args:map[]} Nonclave:{Measurement: Args:map[]} Proxy:{Addr:http://127.0.0.1:8082 AddrTLS: RevAddr:http://0.0.0.0:8080 RevAddrTLS:}}"
[proxy  ] time=2026-01-18T09:39:12.065-05:00 level=INFO msg="proxy server started" addr=0.0.0.0:8080
[nonclave       ] time=2026-01-18T09:39:12.174-05:00 level=INFO msg="loaded config" configs/nonclave/notee.yaml="&{Platform:notee Enclave:{Addr: AddrTLS: Args:map[]} Nonclave:{Measurement:Not a TEE platform. Code measurements are not real. Args:map[]} Proxy:{Addr: AddrTLS: RevAddr: RevAddrTLS:}}"
[proxy  ] time=2026-01-18T09:39:12.177-05:00 level=INFO msg="sending attestation request to enclave..."
[proxy  ] time=2026-01-18T09:39:12.178-05:00 level=INFO msg="waiting for attestation from enclave..."
[enclave        ] time=2026-01-18T09:39:12.178-05:00 level=INFO msg=attesting nonce="random nonce here" userdata="Hello, world!"
[enclave        ] time=2026-01-18T09:39:12.179-05:00 level=INFO msg="sending attestation to enclave-proxy..."
[enclave        ] time=2026-01-18T09:39:12.179-05:00 level=INFO msg="waiting to receive userdata from enclave-proxy..."
[proxy  ] time=2026-01-18T09:39:12.179-05:00 level=INFO msg="sent attestation to client"
[nonclave       ] time=2026-01-18T09:39:12.180-05:00 level=INFO msg="attested and verified userdata" userdata="Hello, world!"
```

## Running on the Cloud

Follow the setup
[instructions](https://github.com/tahardi/bearclave/blob/main/docs/setup.md#install--setup-no-tee)
in the Bearclave SDK repository to configure your cloud environment.

### AWS Nitro Enclaves

The build and deployment process for AWS Nitro Enclaves is different and more
involved than for AMD SEV-SNP and Intel TDX on GCP. Follow the steps below
to build and deploy the example as an AWS Nitro Enclave.

1. SSH into your EC2 instance. There are convenience targets in the Makefile
for logging into the aws cli tool, starting your instance, and ssh'ing into
your instance.
```bash
make aws-cli-login
make aws-nitro-instance-start
make aws-nitro-instance-ssh
```

2. Clone `bearclave-examples` on your EC2 instance and switch to this example's
directory.
```bash
git clone git@github.com:tahardi/bearclave-examples.git
cd bearclave-examples/hello-world
```

3. Build the Enclave and run it in debug mode.
```bash
make aws-nitro-enclave-run-eif-debug 
```

4. In a separate terminal window, ssh into your EC2 instance again and start
the Proxy.
```bash
make aws-nitro-instance-ssh
cd bearclave-examples/hello-world
make aws-nitro-proxy-run 
```

5. In a separate terminal window, run the Nonclave. Note that you will need to
edit the `measurement` variable in `configs/nonclave/nitro.yaml` since we are
running the Enclave in debug mode. When Nitro Enclaves are running in debug mode,
PCRs 0-2 are set to zeros. Either copy the zero value from PCR3 or run the
Nonclave and copy the "got" value from the measurement mismatch error log.

```bash
make aws-nitro-nonclave-run
```

6. Assuming the measurement in your config is correct, you should see the
nonclave successfully verify the attestation report and output the witnessed
data. Remember to shutdown your EC2 instance when you are done.

```bash
exit
make aws-nitro-instance-stop
```

### GCP AMD SEV-SNP & Intel TDX

The build and deployment process for AMD SEV-SNP and Intel TDX on GCP is simpler
than for AWS Nitro Enclaves and can be done from your local machine. Follow the
steps below to build and deploy the example as an AMD SEV-SNP or Intel TDX
Enclave. Note that the commands below are for AMD SEV-SNP, but you can replace
every `sev` with `tdx` to deploy the example on Intel TDX.

1. Start your compute instance.
```bash
make gcp-sev-instance-start
```

2. Build and deploy the Proxy and Enclave. Here is where we see a major difference
between AWS Nitro and AMD SEV-SNP/Intel TDX. Both the Proxy and Enclave are
deployed together within the confidential VM, whereas on Nitro only the Enclave
resides in the VM and the Proxy is outside on the untrusted host.
```bash
make gcp-sev-enclave-run-image 
```

3. Run the Nonclave. You will have to update the expected measurement in
`configs/nonclave/sev.yaml` as certain fields change between AMD SEV-SNP
confidential VM lifecycles (e.g., `report_id`). To determine what the expected
measurement should be, we recommend running the Nonclave and copying the `got`
field from the error log message. Once you have the correct expected measurement,
the Nonclave should successfully verify the attestation report and output the
witnessed data.
```bash
make gcp-sev-nonclave-run 
```

4. Remember to shutdown your instance(s) when you are done.
```bash
make gcp-sev-instance-stop 
```

## Next Steps

You now know how to build and deploy Bearclave applications to cloud-based TEE
platforms! Check out the [next example](../hello-http/README.md) to learn how to
configure the Proxy as a true HTTP reverse proxy and the Enclave as an HTTP
server.
